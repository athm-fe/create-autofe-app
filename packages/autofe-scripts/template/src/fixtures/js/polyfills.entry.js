// require('autofe-polyfill');
// require('babel-polyfill');

// Symbol + Iterator

// Object.assign
if (!Object.assign) {
  Object.assign = function assign(target) {
    for (let index = 1; index < arguments.length; index += 1) {
      const src = arguments[index];

      for (const key in src) {
        if (Object.prototype.hasOwnProperty.call(src, key)) {
          target[key] = src[key];
        }
      }
    }

    return target;
  };
}

// Array.from
if (!Array.from) {
  // Wrapped in IIFE to prevent leaking to global scope.
  (function () {
    function parseIterable (arraylike) {
      var done = false;
      var iterableResponse;
      var tempArray = [];

      // if the iterable doesn't have next;
      // it is an iterable if 'next' is a function but it has not been defined on
      // the object itself.
      if (typeof arraylike.next === 'function') {
        while (!done) {
          iterableResponse = arraylike.next();
          if (
            iterableResponse.hasOwnProperty('value') &&
            iterableResponse.hasOwnProperty('done')
          ) {
            if (iterableResponse.done === true) {
              done = true;
              break;

            // handle the case where the done value is not Boolean
            } else if (iterableResponse.done !== false) {
              break;
            }

            tempArray.push(iterableResponse.value);
          } else {

            // it does not conform to the iterable pattern
            break;
          }
        }
      }

      if (done) {
        return tempArray;
      } else {

        // something went wrong return false;
        return false;
      }

    }

    Array.from = function from(source) {
      // handle non-objects
      if (source === undefined || source === null) {
        throw new TypeError(source + ' is not an object');
      }

      // handle maps that are not functions
      if (1 in arguments && !(arguments[1] instanceof Function)) {
        throw new TypeError(arguments[1] + ' is not a function');
      }

      var arraylike = typeof source === 'string' ? source.split('') : Object(source);
      var map = arguments[1];
      var scope = arguments[2];
      var array = [];
      var index = -1;
      var length = Math.min(Math.max(Number(arraylike.length) || 0, 0), 9007199254740991);
      var value;

      // variables for rebuilding array from iterator
      var arrayFromIterable;

      // if it is an iterable treat like one
      arrayFromIterable = parseIterable(arraylike);

      // if it is a Map or a Set then handle them appropriately
      if (
        typeof arraylike.entries === 'function' &&
        typeof arraylike.values === 'function'
      ) {
        if (arraylike.constructor.name === 'Set' && 'values' in Set.prototype) {
          arrayFromIterable = parseIterable(arraylike.values());
        }
        if (arraylike.constructor.name === 'Map' && 'entries' in Map.prototype) {
          arrayFromIterable = parseIterable(arraylike.entries());
        }
      }

      if (arrayFromIterable) {
        arraylike = arrayFromIterable;
        length = arrayFromIterable.length;
      }

      while (++index < length) {
        value = arraylike[index];
        array[index] = map ? map.call(scope, value, index) : value;
      }

      array.length = length;

      return array;
    };
  }());
}
